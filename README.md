# Примеры SQL Задач

## Описание

Этот репозиторий содержит SQL скрипты для создания, заполнения и запросов к различным базам данных. Цель - отточить навыки работы с SQL, решая разнообразные задачи, связанные с анализом данных, отчетностью и иерархическими запросами.  Каждая задача реализована в отдельной ветке.

## Структура Репозитория

*   **Корневая Директория:**
    *   `README.md` (Этот файл)

*   **Директории, относящиеся к определенной ветке:**
    *   Каждая ветка (например, `task1`, `task2`, `task3`, `task4`) содержит файлы решений, относящиеся к конкретной задаче.
    *   Каждая ветка содержит следующие файлы:
        *   `create_tables.sql`: Содержит скрипт для создания таблиц для конкретной задачи.
        *   `populate_data.sql`: Содержит скрипт для заполнения таблиц данными.
        *   `solution`: Содержит SQL запрос для решения задачи.

## Схемы Баз Данных и Задачи

Каждая ветка представляет собой отдельную схему базы данных и связанные с ней задачи.

### Task 1: База Данных Учета Транспортных Средств

*   **Описание Схемы:**
    *   `Vehicle`: Хранит общую информацию о транспортных средствах.
        *   `maker` (VARCHAR): Производитель транспортного средства.
        *   `model` (VARCHAR, PRIMARY KEY): Модель транспортного средства.
        *   `type` (ENUM): Тип транспортного средства ('Car' - автомобиль, 'Motorcycle' - мотоцикл, 'Bicycle' - велосипед).
    *   `Car`: Хранит информацию, специфичную для автомобилей.
        *   `vin` (VARCHAR, PRIMARY KEY): VIN (Vehicle Identification Number - идентификационный номер транспортного средства).
        *   `model` (VARCHAR, FOREIGN KEY): Ссылка на Vehicle.model.
        *   `engine_capacity` (DECIMAL): Объем двигателя в литрах.
        *   `horsepower` (INT): Мощность в лошадиных силах.
        *   `price` (DECIMAL): Цена.
        *   `transmission` (ENUM): Тип трансмиссии ('Automatic' - автоматическая, 'Manual' - механическая).
    *   `Motorcycle`: Хранит информацию, специфичную для мотоциклов.
        *   `vin` (VARCHAR, PRIMARY KEY): VIN.
        *   `model` (VARCHAR, FOREIGN KEY): Ссылка на Vehicle.model.
        *   `engine_capacity` (DECIMAL): Объем двигателя в литрах.
        *   `horsepower` (INT): Мощность в лошадиных силах.
        *   `price` (DECIMAL): Цена.
        *   `type` (ENUM): Тип мотоцикла ('Sport' - спортивный, 'Cruiser' - круизер, 'Touring' - туристический).
    *   `Bicycle`: Хранит информацию, специфичную для велосипедов.
        *   `serial_number` (VARCHAR, PRIMARY KEY): Серийный номер.
        *   `model` (VARCHAR, FOREIGN KEY): Ссылка на Vehicle.model.
        *   `gear_count` (INT): Количество передач.
        *   `price` (DECIMAL): Цена.
        *   `type` (ENUM): Тип велосипеда ('Mountain' - горный, 'Road' - шоссейный, 'Hybrid' - гибрид).

*   **Задача 1-1**
    *   Условие

Найдите производителей (maker) и модели всех мотоциклов, которые имеют мощность более 150 лошадиных сил, стоят менее 20 тысяч долларов и являются спортивными (тип Sport). Также отсортируйте результаты по мощности в порядке убывания.

*   **Задача 1-2**
    *   Условие
Найти информацию о производителях и моделях различных типов транспортных средств (автомобили, мотоциклы и велосипеды), которые соответствуют заданным критериям.

Автомобили:
Извлечь данные о всех автомобилях, которые имеют:

Мощность двигателя более 150 лошадиных сил.
Объем двигателя менее 3 литров.
Цену менее 35 тысяч долларов.
В выводе должны быть указаны производитель (maker), номер модели (model), мощность (horsepower), объем двигателя (engine_capacity) и тип транспортного средства, который будет обозначен как Car.

Мотоциклы:
Извлечь данные о всех мотоциклах, которые имеют:

Мощность двигателя более 150 лошадиных сил.
Объем двигателя менее 1,5 литров.
Цену менее 20 тысяч долларов.
В выводе должны быть указаны производитель (maker), номер модели (model), мощность (horsepower), объем двигателя (engine_capacity) и тип транспортного средства, который будет обозначен как Motorcycle.

Велосипеды:
Извлечь данные обо всех велосипедах, которые имеют:

Количество передач больше 18.
Цену менее 4 тысяч долларов.
В выводе должны быть указаны производитель (maker), номер модели (model), а также NULL для мощности и объема двигателя, так как эти характеристики не применимы для велосипедов. Тип транспортного средства будет обозначен как Bicycle.

Сортировка:
Результаты должны быть объединены в один набор данных и отсортированы по мощности в порядке убывания. Для велосипедов, у которых нет значения мощности, они будут располагаться внизу списка.

### Task 2: База Данных Автогонок

*   **Описание Схемы:**
    *   `Classes`: Хранит информацию о классах автомобилей.
        *   `class` (VARCHAR, PRIMARY KEY): Название класса.
        *   `type` (ENUM): 'Racing' (гоночный) или 'Street' (уличный).
        *   `country` (VARCHAR): Страна происхождения.
        *   `numDoors` (INT): Количество дверей.
        *   `engineSize` (DECIMAL): Объем двигателя в литрах.
        *   `weight` (INT): Вес автомобиля в килограммах.
    *   `Cars`: Хранит информацию об автомобилях.
        *   `name` (VARCHAR, PRIMARY KEY): Название автомобиля.
        *   `class` (VARCHAR, FOREIGN KEY): Ссылка на Classes.class.
        *   `year` (INT): Год выпуска.
    *   `Races`: Хранит информацию о гонках.
        *   `name` (VARCHAR, PRIMARY KEY): Название гонки.
        *   `date` (DATE): Дата гонки.
    *   `Results`: Хранит результаты гонок.
        *   `car` (VARCHAR, FOREIGN KEY): Ссылка на Cars.name.
        *   `race` (VARCHAR, FOREIGN KEY): Ссылка на Races.name.
        *   `position` (INT): Занятое место.

*   **Задача 2-1**
    *   Условие
Определить, какие автомобили из каждого класса имеют наименьшую среднюю позицию в гонках, и вывести информацию о каждом таком автомобиле для данного класса, включая его класс, среднюю позицию и количество гонок, в которых он участвовал. Также отсортировать результаты по средней позиции.

*   **Задача 2-2**
    *   Условие
Определить автомобиль, который имеет наименьшую среднюю позицию в гонках среди всех автомобилей, и вывести информацию об этом автомобиле, включая его класс, среднюю позицию, количество гонок, в которых он участвовал, и страну производства класса автомобиля. Если несколько автомобилей имеют одинаковую наименьшую среднюю позицию, выбрать один из них по алфавиту (по имени автомобиля).

*   **Задача 2-3**
    *   Условие
Определить классы автомобилей, которые имеют наименьшую среднюю позицию в гонках, и вывести информацию о каждом автомобиле из этих классов, включая его имя, среднюю позицию, количество гонок, в которых он участвовал, страну производства класса автомобиля, а также общее количество гонок, в которых участвовали автомобили этих классов. Если несколько классов имеют одинаковую среднюю позицию, выбрать все из них.

*   **Задача 2-4**
    *   Условие
Определить, какие автомобили имеют среднюю позицию лучше (меньше) средней позиции всех автомобилей в своем классе (то есть автомобилей в классе должно быть минимум два, чтобы выбрать один из них). Вывести информацию об этих автомобилях, включая их имя, класс, среднюю позицию, количество гонок, в которых они участвовали, и страну производства класса автомобиля. Также отсортировать результаты по классу и затем по средней позиции в порядке возрастания.

*   **Задача 2-5**
    *   Условие
Определить, какие классы автомобилей имеют наибольшее количество автомобилей с низкой средней позицией (больше 3.0) и вывести информацию о каждом автомобиле из этих классов, включая его имя, класс, среднюю позицию, количество гонок, в которых он участвовал, страну производства класса автомобиля, а также общее количество гонок для каждого класса. Отсортировать результаты по количеству автомобилей с низкой средней позицией.

### Task 3: База Данных Бронирований Отелей

*   **Описание Схемы:**
    *   `Hotel`: Хранит информацию об отелях.
        *   `ID_hotel` (INT, PRIMARY KEY): Уникальный идентификатор отеля.
        *   `name` (VARCHAR): Название отеля.
        *   `location` (VARCHAR): Местоположение отеля.
    *   `Room`: Хранит информацию о номерах в отелях.
        *   `ID_room` (INT, PRIMARY KEY): Уникальный идентификатор номера.
        *   `ID_hotel` (INT, FOREIGN KEY): Ссылка на Hotel.ID_hotel.
        *   `room_type` (ENUM): Тип номера ('Single' - одноместный, 'Double' - двухместный, 'Suite' - люкс).
        *   `price` (DECIMAL): Цена номера.
        *   `capacity` (INT): Вместимость номера.
    *   `Customer`: Хранит информацию о клиентах.
        *   `ID_customer` (INT, PRIMARY KEY): Уникальный идентификатор клиента.
        *   `name` (VARCHAR): Имя клиента.
        *   `email` (VARCHAR, UNIQUE): Адрес электронной почты клиента.
        *   `phone` (VARCHAR): Номер телефона клиента.
    *   `Booking`: Хранит информацию о бронированиях.
        *   `ID_booking` (INT, PRIMARY KEY): Уникальный идентификатор бронирования.
        *   `ID_room` (INT, FOREIGN KEY): Ссылка на Room.ID_room.
        *   `ID_customer` (INT, FOREIGN KEY): Ссылка на Customer.ID_customer.
        *   `check_in_date` (DATE): Дата заезда.
        *   `check_out_date` (DATE): Дата выезда.

*   **Задача 3-1**
    *   Условие
Определить, какие клиенты сделали более двух бронирований в разных отелях, и вывести информацию о каждом таком клиенте, включая его имя, электронную почту, телефон, общее количество бронирований, а также список отелей, в которых они бронировали номера (объединенные в одно поле через запятую с помощью CONCAT). Также подсчитать среднюю длительность их пребывания (в днях) по всем бронированиям. Отсортировать результаты по количеству бронирований в порядке убывания.

*   **Задача 3-2**
    *   Условие
Необходимо провести анализ клиентов, которые сделали более двух бронирований в разных отелях и потратили более 500 долларов на свои бронирования. Для этого:

Определить клиентов, которые сделали более двух бронирований и забронировали номера в более чем одном отеле. Вывести для каждого такого клиента следующие данные: ID_customer, имя, общее количество бронирований, общее количество уникальных отелей, в которых они бронировали номера, и общую сумму, потраченную на бронирования.
Также определить клиентов, которые потратили более 500 долларов на бронирования, и вывести для них ID_customer, имя, общую сумму, потраченную на бронирования, и общее количество бронирований.
В результате объединить данные из первых двух пунктов, чтобы получить список клиентов, которые соответствуют условиям обоих запросов. Отобразить поля: ID_customer, имя, общее количество бронирований, общую сумму, потраченную на бронирования, и общее количество уникальных отелей.
Результаты отсортировать по общей сумме, потраченной клиентами, в порядке возрастания.

*   **Задача 3-3**
    *   Условие
Вам необходимо провести анализ данных о бронированиях в отелях и определить предпочтения клиентов по типу отелей. Для этого выполните следующие шаги:

Категоризация отелей.
Определите категорию каждого отеля на основе средней стоимости номера:

«Дешевый»: средняя стоимость менее 175 долларов.
«Средний»: средняя стоимость от 175 до 300 долларов.
«Дорогой»: средняя стоимость более 300 долларов.
Анализ предпочтений клиентов.
Для каждого клиента определите предпочитаемый тип отеля на основании условия ниже:

Если у клиента есть хотя бы один «дорогой» отель, присвойте ему категорию «дорогой».
Если у клиента нет «дорогих» отелей, но есть хотя бы один «средний», присвойте ему категорию «средний».
Если у клиента нет «дорогих» и «средних» отелей, но есть «дешевые», присвойте ему категорию предпочитаемых отелей «дешевый».
Вывод информации.
Выведите для каждого клиента следующую информацию:

ID_customer: уникальный идентификатор клиента.
name: имя клиента.
preferred_hotel_type: предпочитаемый тип отеля.
visited_hotels: список уникальных отелей, которые посетил клиент.
Сортировка результатов.
Отсортируйте клиентов так, чтобы сначала шли клиенты с «дешевыми» отелями, затем со «средними» и в конце — с «дорогими».

### Task 4: База Данных Управления Персоналом

*   **Описание Схемы:**
    *   `Departments`: Хранит информацию об отделах компании.
        *   `DepartmentID` (INT, PRIMARY KEY): Уникальный идентификатор отдела.
        *   `DepartmentName` (VARCHAR): Название отдела.
    *   `Roles`: Хранит информацию о должностях сотрудников.
        *   `RoleID` (INT, PRIMARY KEY): Уникальный идентификатор должности.
        *   `RoleName` (VARCHAR): Название должности.
    *   `Employees`: Хранит информацию о сотрудниках и их иерархической структуре.
        *   `EmployeeID` (INT, PRIMARY KEY): Уникальный идентификатор сотрудника.
        *   `Name` (VARCHAR): Имя сотрудника.
        *   `Position` (VARCHAR): Должность сотрудника.
        *   `ManagerID` (INT, FOREIGN KEY): Ссылка на Employees.EmployeeID (руководитель сотрудника).
        *   `DepartmentID` (INT, FOREIGN KEY): Ссылка на Departments.DepartmentID.
        *   `RoleID` (INT, FOREIGN KEY): Ссылка на Roles.RoleID.
    *   `Projects`: Хранит информацию о проектах.
        *   `ProjectID` (INT, PRIMARY KEY): Уникальный идентификатор проекта.
        *   `ProjectName` (VARCHAR): Название проекта.
        *   `StartDate` (DATE): Дата начала проекта.
        *   `EndDate` (DATE): Дата окончания проекта.
        *   `DepartmentID` (INT, FOREIGN KEY): Ссылка на Departments.DepartmentID.
    *   `Tasks`: Хранит информацию о задачах, назначенных сотрудникам.
        *   `TaskID` (INT, PRIMARY KEY): Уникальный идентификатор задачи.
        *   `TaskName` (VARCHAR): Название задачи.
        *   `AssignedTo` (INT, FOREIGN KEY): Ссылка на Employees.EmployeeID (сотрудник, назначенный на задачу).
        *   `ProjectID` (INT, FOREIGN KEY): Ссылка на Projects.ProjectID.

*   **Задача 4-1**
    *   Условие
Найти всех сотрудников, подчиняющихся Ивану Иванову (с EmployeeID = 1), включая их подчиненных и подчиненных подчиненных. Для каждого сотрудника вывести следующую информацию:

EmployeeID: идентификатор сотрудника.
Имя сотрудника.
ManagerID: Идентификатор менеджера.
Название отдела, к которому он принадлежит.
Название роли, которую он занимает.
Название проектов, к которым он относится (если есть, конкатенированные в одном столбце через запятую).
Название задач, назначенных этому сотруднику (если есть, конкатенированные в одном столбце через запятую).
Если у сотрудника нет назначенных проектов или задач, отобразить NULL.
Требования:

Рекурсивно извлечь всех подчиненных сотрудников Ивана Иванова и их подчиненных.
Для каждого сотрудника отобразить информацию из всех таблиц.
Результаты должны быть отсортированы по имени сотрудника.
Решение задачи должно представлять из себя один sql-запрос и задействовать ключевое слово RECURSIVE.

*   **Задача 4-2**
    *   Условие
Найти всех сотрудников, подчиняющихся Ивану Иванову с EmployeeID = 1, включая их подчиненных и подчиненных подчиненных. Для каждого сотрудника вывести следующую информацию:

EmployeeID: идентификатор сотрудника.
Имя сотрудника.
Идентификатор менеджера.
Название отдела, к которому он принадлежит.
Название роли, которую он занимает.
Название проектов, к которым он относится (если есть, конкатенированные в одном столбце).
Название задач, назначенных этому сотруднику (если есть, конкатенированные в одном столбце).
Общее количество задач, назначенных этому сотруднику.
Общее количество подчиненных у каждого сотрудника (не включая подчиненных их подчиненных).
Если у сотрудника нет назначенных проектов или задач, отобразить NULL.

*   **Задача 4-2**
    *   Условие
Найти всех сотрудников, которые занимают роль менеджера и имеют подчиненных (то есть число подчиненных больше 0). Для каждого такого сотрудника вывести следующую информацию:

EmployeeID: идентификатор сотрудника.
Имя сотрудника.
Идентификатор менеджера.
Название отдела, к которому он принадлежит.
Название роли, которую он занимает.
Название проектов, к которым он относится (если есть, конкатенированные в одном столбце).
Название задач, назначенных этому сотруднику (если есть, конкатенированные в одном столбце).
Общее количество подчиненных у каждого сотрудника (включая их подчиненных).
Если у сотрудника нет назначенных проектов или задач, отобразить NULL.


## Инструкции по Использованию

1.  **Клонировать репозиторий:**
    ```bash
    git clone <https://github.com/KseniiaFed-dev/MySQL.git>
    cd <https://github.com/KseniiaFed-dev/MySQL.git>
    ```

2.  **Переключиться на нужную ветку:**
    ```bash
    git checkout task-1  # Замените на task-2, task-3, task-4
    ```

3.  **Создать базу данных и таблицы:**
    Подключитесь к своему серверу баз данных (MySQL), используя предпочитаемый клиент (например, MySQL Workbench, pgAdmin, интерфейс командной строки). Затем выполните скрипт `create_tables.sql`, расположенный в текущей ветке.

    ```bash
    mysql -u your_user -p < create_tables.sql 
    ```

    Замените `<your_user>`, `<your_database>` на свои учетные данные для базы данных.

4.  **Заполнить базу данных данными:**
    Запустите скрипт `populate_data.sql`, расположенный в текущей ветке:

    ```bash
    mysql -u your_user -p < populate_data.sql  
    ```

5.  **Запустить SQL запросы:**
    Решения SQL запросов находятся в файле `solution.sql` в текущей ветке.  Вы можете выполнить их, используя свой клиент базы данных.

    ```bash
    mysql -u your_user -p -e "solution.sql" your_database 
    ```

    Замените `<your_user>`, `<your_database>` на свои учетные данные для базы данных и `solution.sql` на имя файла запроса (например, `solution 1-1.sql`, `solution 1-2.sql`).

## Стратегия Ветвления

*   Каждая задача реализована в отдельной ветке. Это упрощает проверку отдельных решений и предотвращает конфликты при слиянии во время разработки.
*   Каждая ветка имеет свои собственные файлы `create_tables.sql`, `populate_data.sql` и `solution.sql`, что делает их полностью независимыми.
